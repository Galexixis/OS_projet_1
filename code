/***********************************************
 * Project: Reverse
 * 
 * Group Number :12
 * Students     :Fontaine Alexis / Beernaut Mathis
 * 
 ***********************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct my_tab{
    char **tab;
    //size représente le nombre d'élément déjà présent dans tab
    unsigned size;
};

//return une struct my_tab qui stock un tableau de pointeur de char et sa taille
struct my_tab creation_tab(){
    char **pointeur = malloc(1*sizeof(char *));
    if (pointeur==NULL){
        //erreur alloc à échoué
        fprintf(stderr,"error: malloc failed");
        exit(1);
    }
    unsigned size = 0;
    struct my_tab my_structure;
    my_structure.size=0;
    my_structure.tab=pointeur;
    return my_structure;
}

//ajoute un pointeur de char à la fin d'un tab dans une struct my_tab
int ajout_tab(struct my_tab *pointeur_my_structure, char *text){
    char **tab = pointeur_my_structure->tab;
    tab = realloc(tab, (pointeur_my_structure->size + 1)*sizeof(char *));
    if (tab==NULL){
        //erreur realloc à échoué
        fprintf(stderr,"error: realloc failed");
        exit(1);
    }
    tab[pointeur_my_structure->size]=text;
    pointeur_my_structure->size=pointeur_my_structure->size + 1;
    pointeur_my_structure->tab=tab;
    return EXIT_SUCCESS;
}

//ouvre un ficher en mode lecture et return un pointeur
FILE *lecture_file(char *fichier){
    FILE *pointeur=fopen(fichier, "r");
    if (pointeur==NULL){
        //erreur d'ouverture du fichier
        fprintf(stderr,"error: cannot open file %s",fichier);
        exit(1);
    }
    return pointeur;
}

//ouvre un ficher en mode écriture et return un pointeur
FILE *writing_mod_file(char *fichier){
    FILE *pointeur=fopen(fichier, "w");
    if (pointeur==NULL){
        //erreur d'ouverture du fichier
        fprintf(stderr,"error: cannot open file %s",fichier);
        exit(1);
    }
    return pointeur;
}

//lit toute les lignes d'un fichier et les stock dans une struct my_tab
struct my_tab lire_ligne(FILE *fichier){
    struct my_tab liste=creation_tab();
    while(1){
        char *ligne = NULL;
        size_t taille=0;
        int size = getline(&ligne, &taille, fichier);
        if (size == -1){
            free(ligne);
            break;
        }
    ajout_tab(&liste , ligne);
    }
    return liste;
}

//lit toute les lignes sur le flux standard et les stock dans une structure my_tab
struct my_tab stdin_ligne(){
    struct my_tab liste=creation_tab();

    //code suite

    return liste;
}

//écrit dans un fichier (ou la sortie standard si elle est passé en argument) toute les chaine de caractère pointé par les pointeur d'une structure my_tab. Free tous se qui est écrit
int ecriture_file(FILE *sortie,struct my_tab *pointeur_my_structure){
    int indice = pointeur_my_structure->size -1;
    while (indice >= 0){
        fprintf(sortie, "%s" ,pointeur_my_structure->tab[indice]);
        free(pointeur_my_structure->tab[indice]);
        indice--;
    }
    free(pointeur_my_structure->tab);
    return EXIT_SUCCESS;
}

int main(int argc, char *argv[]) {

    //appel avec un nombre d'argument non valide
    if(argc>=4){
        //erreur lancer
        fprintf(stderr,"error: you can only have 0 , 1 , 2 argument");
        exit(1);
    }
    
    //appel avec 0 argument
    if(argc==1){
        struct my_tab liste = stdin_ligne();
        ecriture_file(stdout, &liste);
    }

    //appel avec 1 argument
    if(argc==2){
        FILE *lecture = lecture_file(argv[1]);
        struct my_tab liste = lire_ligne(lecture);
        ecriture_file(stdout, &liste);
    }

    //appel avec 2 argument
    if(argc==3){
        FILE *lecture = lecture_file(argv[1]);
        struct my_tab liste = lire_ligne(lecture);
        FILE *sortie = writing_mod_file(argv[2]);
        ecriture_file(sortie, &liste);
    }


    return EXIT_SUCCESS;
}
